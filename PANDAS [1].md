# PANDAS

- 사용하지 않더라도 일단 가져온다.

- ```
  import warnings
  warnings.filterwarnings('always')
  warnings.filterwarnings('ignore')
  
  import numpy as np
  import pandas as pd
  
  import matplotlib.pyplot as plt
  import seaborn as sns
  ```

  

## 	판다스란?

1. 파이썬에서 사용할 수 있는 데이터 전처리용 패키지
2. 엑셀처럼 파일을 다룰 수 있는 도구
3. 엑셀과 큰 차이점은 1기가 넘어가는 파일도 빠르게 처리 가능한 점
4. 엑셀보다 더 복잡한 처리, 디비와 연동 등의 기능 제공



## 	Series

1. 1차원 구조를 표현
   - series = pd.Series( [10,20,30,40] )
   - 인덱스 / 값 으로 표현된다



## 	DataFrame

1. 2차원 구조

2. 여러개의 시리즈가 모여서 하나의 DataFrame이 된다.

3. weight = pd.DataFrame([[76.4, 'kg'],

   ​            [80.5, 'kg'],

   ​            [87.4, 'kg'],

   ​            [45.4, 'kg']])

   display(weight)

   display(weight.ndim)

   display(weight.shape)

|      |    0 |    1 |
| ---: | ---: | ---: |
|    0 | 76.4 |   kg |
|    1 | 80.5 |   kg |
|    2 | 87.4 |   kg |
|    3 | 45.4 |   kg |

```
2
(4, 2)
```



## 	파일 읽어오기

1. 판다스는 'read_csv'라는 기능으로 파일을 읽어온다.

   - 텍스트가 콤마로 구분된 형태로 되어있는 파일
   - 엑셀, csv, ... 등의 다양한 파일 형태를 읽을 수 있다
   - 데이터 프레임 형태로 변환을 해준다.

2. rawData = pd.read_csv('/content/drive/MyDrive/data/weight_log.csv')

   rawData : 아래와 같이 가져온다.

|      | 회차 |   이름 |     측정일 | 몸무게 | 단위 |   담당 |   지점 |
| ---: | ---: | -----: | ---------: | -----: | ---: | -----: | -----: |
|    0 |    1 | 홍길동 | 2020-03-01 |   76.4 |   kg | 박현경 | 관악구 |
|    1 |    2 | 홍길동 | 2020-03-02 |   75.7 |   kg | 김현경 | 관악구 |
|    2 |    3 | 홍길동 | 2020-03-03 |   76.0 |   kg | 최현경 | 여의도 |
|    3 |    4 | 홍길동 | 2020-03-04 |    NaN |   kg | 최현경 | 여의도 |
|    4 |    5 | 홍길동 | 2020-03-05 |   76.2 |   kg | 김현경 | 강남구 |
|    5 |    6 | 홍길동 | 2020-03-06 |   75.7 |   kg | 최현경 | 서초구 |
|    6 |    7 | 홍길동 | 2020-03-07 |    NaN |   kg | 최현경 | 서초구 |
|    7 |    8 | 홍길동 | 2020-03-08 |    NaN |   kg | 김현경 | 서초구 |
|    8 |    9 | 홍길동 | 2020-03-09 |   75.0 |   kg | 김현경 | 서초구 |

3. NaN은 자료가 없는 곳으로 결측치를 나타낸다.



## 		데이터 프레임 사용하기

1. 상위 /하위 5개의 자료 출력

   - rawData.head() / .tail() : default parameter = 5
   - default parameter 지정 가능

2. 요약된 정보

   - rawData.info()
     - object는 문자열

   - rawData.describe('몸무게') : 몸무게에 대한 분석

3. 인덱싱(색인)

   - 데이터 프레임은 행을 선택하지 않고, 시리즈를 선택하는 방향으로 인덱싱

   - rawData('몸무게')

4. 배열 인덱스 지원

   - col = ['이름', '몸무게', '측정일' ]
   - rawData( col )



## 		행 인덱싱

1. loc / iloc 사용
2. 첫번째 행 인덱싱
   - rawData.head(1)

|      | 회차 |   이름 |     측정일 | 몸무게 | 단위 |   담당 |   지점 |
| ---: | ---: | -----: | ---------: | -----: | ---: | -----: | -----: |
|    0 |    1 | 홍길동 | 2020-03-01 |   76.4 |   kg | 박현경 | 관악구 |

3. loc / iloc사용 : 큰 차이 없음...
   - rawData.loc[0]



## 	슬라이스 가능

### numpy에서 array[ 1:3, 1:3 ]과 다름

### loc 

1. 판다스의 슬라이스는 마지막 인덱스를 포함한다.
2. rawData.loc[0 : 3] : 0,1,2,3 전부 출력
3. rawData.loc[ [1,3,5] ] : 1번 3번 5번 index 출력
4. rawData.loc[ 0, '몸무게' ] : 행, 열 인덱싱
5. rawData.loc[ 0, ['몸무게' , '이름'] ]
6. rawData.loc[ [1, 3, 5] , ['몸무게' , '이름'] ]
7. rawData.loc[ 0:3 , '몸무게' : '이름'] ]



## 	loc	vs	iloc

1. iloc를 사용하면 col 인덱스에 정수를 사용할 수 있다.
   - 마지막 값 포함 안한다.
   - rawData.iloc[ 1:6, 0:4 ] == rawData.loc[ 1:5, '회차':'몸무게' ]



## 	조건 검색

1. 불리언 시리즈로 출력

2. rawData[ '지점' ] == '여의도'

3. rawData[ rawData['지점'] == '여의도' ]

   - |      | 회차 |   이름 |     측정일 | 몸무게 | 단위 |   담당 |   지점 |
     | ---: | ---: | -----: | ---------: | -----: | ---: | -----: | -----: |
     |    2 |    3 | 홍길동 | 2020-03-03 |   76.0 |   kg | 최현경 | 여의도 |
     |    3 |    4 | 홍길동 | 2020-03-04 |    NaN |   kg | 최현경 | 여의도 |

4. rawData[rawData['몸무게'] >= 76]

   - |      | 회차 |   이름 |     측정일 | 몸무게 | 단위 |   담당 |   지점 |
     | ---: | ---: | -----: | ---------: | -----: | ---: | -----: | -----: |
     |    0 |    1 | 홍길동 | 2020-03-01 |   76.4 |   kg | 박현경 | 관악구 |
     |    2 |    3 | 홍길동 | 2020-03-03 |   76.0 |   kg | 최현경 | 여의도 |
     |    4 |    5 | 홍길동 | 2020-03-05 |   76.2 |   kg | 김현경 | 강남구 |



## 	다중조건

1. and, or, not

2. 판다스는 &, |, ! 을 이용하여 표현

   - 우선 순위가 복잡하다.
   - 반드시 괄호를 이용하여 표현한다.

3. rawData[(rawData['지점'] == '서초구') & (rawData['담당'] == '최현경')] : 반드시 괄호를 사용!

   - |      | 회차 |   이름 |     측정일 | 몸무게 | 단위 |   담당 |   지점 |
     | ---: | ---: | -----: | ---------: | -----: | ---: | -----: | -----: |
     |    5 |    6 | 홍길동 | 2020-03-06 |   75.7 |   kg | 최현경 | 서초구 |
     |    6 |    7 | 홍길동 | 2020-03-07 |    NaN |   kg | 최현경 | 서초구 |

4. 서초구 지점의 김현경, 최현경만 출력
   - rawData[(rawData['지점'] == '서초구') & ( (rawData['담당'] == '김현경') | (rawData['담당'] == '최현경') )]

|      | 회차 |   이름 |     측정일 | 몸무게 | 단위 |   담당 |   지점 |
| ---: | ---: | -----: | ---------: | -----: | ---: | -----: | -----: |
|    5 |    6 | 홍길동 | 2020-03-06 |   75.7 |   kg | 최현경 | 서초구 |
|    6 |    7 | 홍길동 | 2020-03-07 |    NaN |   kg | 최현경 | 서초구 |
|    7 |    8 | 홍길동 | 2020-03-08 |    NaN |   kg | 김현경 | 서초구 |
|    8 |    9 | 홍길동 | 2020-03-09 |   75.0 |   kg | 김현경 | 서초구 |

5. 4번을 쉽게하는 법...
   - isin은 리스트를 parameter로 갖는다.
   - 리스트 내의 값 중에서 하나라도 존재하면 True, 그렇지 않으면 False
   - rawData[ (rawData['지점']== '서초구') & (rawData['담당'].isin(['김현경', '최현경']))]
   - 즉, rawData['담당']. isin ( ['김현경', '최현경'] )



## 	문자열 처리

1. 담당자가 김씨 인 경우
   - str.contains( ) 이용
     - rawData[ rawData[ '담당' ].str.contains('김') ]
   - startswith( ) 이용
     - rawData[ rawData['담당'].startswith('김') ]



## 	결측치 처리

1. 결측치가 있으면 분석을 수행할 수 없다.
2. 꼭 결측치를 채우거나 지워야한다.
3. 채우는 방법
   - 평균, 중앙값 등으로 대체하는 경우
   - 실제론...유용하지 않을수도..??
4. 결측치 및 개수를 확인하는 방법
   - rawData['몸무게'].isnull() / isna()
   - rawData['몸무게'].isnull().sum() : True는 1, False는 0
5. 결측치만 출력
   - rawData[ rawData['몸무게'].isna() ]
6. 결측치 제외 출력 : 부정 '~' 을 사용
   - rawData[ ~ rawData['몸무게'].isna() ]
   - rawData[ rawData['몸무게'].notna() ]
7. 몸무게가 결측치인 사람의 이름 : 이름은 col
   - rawData.loc[ rawData['몸무게'].isna() , '이름' ]
8. 몸무게가 결측치인 사람의 이름과 담당 : 이름은 col
   - rawData.loc[ rawData['몸무게'].isna() , ['이름', '담당'] ]



## 	이상치 처리

1. 특별히 크거나, 작은 값
   - 얼마나 크거나, 작아야 이상치라고 할지 분석가의 재량
2. 이상치를 찾는 경우가 아니라면, 이상치는 제거하고 분석을 진행!
   - 75% 가 넘어가면 판단하겠다! 라고 할 수 있음
3. 4분위 수를 이용한 방법

display( rawData['몸무게'].quantile(0.25))

display( rawData['몸무게'].quantile(0.50))

display( rawData['몸무게'].quantile(0.75))

display( rawData['몸무게'].quantile(0.99))

4. 이상치를 상위 99% 이상, 하위 0.1% 이하

low = rawData['몸무게'].quantile(0.01)

high = rawData['몸무게'].quantile(0.99)

rawData[ (rawData['몸무게'] < high ) & (rawData['몸무게'] > low) ]



## 	중복된 데이터 검사

### DUPLICATED

1. duplicated 를 이용해서 중복된 자료를 검사
2. rawData.duplicated( subset = '지점') : 불리언으로 출력
3. rawData[rawData.duplicated( subset = '지점', keep = False)] : 중복된 것 모두 보여준다.

|      | 회차 |   이름 |     측정일 | 몸무게 | 단위 |   담당 |   지점 |
| ---: | ---: | -----: | ---------: | -----: | ---: | -----: | -----: |
|    0 |    1 | 홍길동 | 2020-03-01 |   76.4 |   kg | 박현경 | 관악구 |
|    1 |    2 | 홍길동 | 2020-03-02 |   75.7 |   kg | 김현경 | 관악구 |
|    2 |    3 | 홍길동 | 2020-03-03 |   76.0 |   kg | 최현경 | 여의도 |
|    3 |    4 | 홍길동 | 2020-03-04 |    NaN |   kg | 최현경 | 여의도 |
|    5 |    6 | 홍길동 | 2020-03-06 |   75.7 |   kg | 최현경 | 서초구 |
|    6 |    7 | 홍길동 | 2020-03-07 |    NaN |   kg | 최현경 | 서초구 |
|    7 |    8 | 홍길동 | 2020-03-08 |    NaN |   kg | 김현경 | 서초구 |
|    8 |    9 | 홍길동 | 2020-03-09 |   75.0 |   kg | 김현경 | 서초구 |



## 	통계분석

1. 판다스에서 제공하는 통계 관련 기능
   - pivot / crosstab / 그룹화

### PIVOT

1. 지점별 몸무게 평균

   - pd.pivot_table( rawData, index = '지점', values = '몸무게') : 디폴트 패러미터는 평균!

   |        | 몸무게 |
   | -----: | -----: |
   |   지점 |        |
   | 강남구 |  76.20 |
   | 관악구 |  76.05 |
   | 서초구 |  75.35 |
   | 여의도 |  76.00 |

3. 지점별 몸무게 총합

   - pd.pivot_table( rawData, index = '지점', values = '몸무게', aggfunc=np.sum)

   |        | 몸무게 |
   | -----: | -----: |
   |   지점 |        |
   | 강남구 |   76.2 |
   | 관악구 |  152.1 |
   | 서초구 |  150.7 |
   | 여의도 |   76.0 |

4. 지점별, 담당자별 몸무게의 평균

   - pd.pivot_table( rawData, index = ['지점', '담당'], values = '몸무게')

   |        |        | 몸무게 |
   | -----: | -----: | -----: |
   |   지점 |   담당 |        |
   | 강남구 | 김현경 |   76.2 |
   | 관악구 | 김현경 |   75.7 |
   | 박현경 |   76.4 |        |
   | 서초구 | 김현경 |   75.0 |
   | 최현경 |   75.7 |        |
   | 여의도 | 최현경 |   76.0 |



### CORSSTAB

1. pd.crosstab( index = rawData['지점'], columns=rawData['담당'], values = rawData['몸무게'], aggfunc=np.mean)

- |   담당 | 김현경 | 박현경 | 최현경 |
  | -----: | -----: | -----: | -----: |
  |   지점 |        |        |        |
  | 강남구 |   76.2 |    NaN |    NaN |
  | 관악구 |   75.7 |   76.4 |    NaN |
  | 서초구 |   75.0 |    NaN |   75.7 |
  | 여의도 |    NaN |    NaN |   76.0 |



### GRUOPBY

1. 지점별 그룹화

   - rawData.groupby(['지점'])

   - 그룹화된 것을 몸무게의 평균으로
     - rawData.groupby(['지점'])['몸무게'].mean()

2. 지점별 몸무게의 평균

   - rawData.groupby(['지점'])['몸무게'].mean()

3. 지점별 담당별 몸무게의 평균

   - rawData.groupby(['지점', '담당'])['몸무게'].mean()

4. 지점별 [몸무게의 평균] / [담당의 수]

   - rawData.groupby('지점').agg({'몸무게': 'mean', '담당': 'count'})



## 	데이터 프레임 조작하기

추가, 수정, 삭제

### 열

#### 열의 추가와 수정

1. 없는 col은 추가 한다.
   - rawData['지역'] = '서울'
2. 존재하는 col은 값이 수정된다.
   - rawData['지역'] = 'Seoul'

#### 조건에 맞는 열 추가

1. 몸무게가 특정값 이상이면 '비만', 그렇지 않으면 '정상'

#### 열 삭제 drop 이용

1. 항상 신중하게!
   - 원본 데이터는 소중해...
2. rawData.drop(columns=['지역']) : 새로운 데이터를 return 해줌
   - 원본은 남아있다!
3. rawData.drop(columns = ['지역'], inplace=True)
   - inplace 패러미터 때문에 원본이 바뀌어버림 : 반환값없음



### 행 

#### 행 추가와 수정, 삭제

1. 추가 rawData.loc[9] = [10, '홍길동', '202020', ........ ]
2. 삭제 rawData.drop(index = [0,1,2] )



## apply

### 	기본 사용 방법

#### 		열 기준

def func(x):

 print('\n함수가 호출되었습니다.')

 print('x : {}'.format(x) )

 return

rawData.apply( func )

#### 		행 기준

rawData.apply( func, axis=1 )



#### 		지점별로 지역을 새로 만들어보자!

def func(x):

 if x['지점'] == '관악구': return '강서'

 elif x['지점'] == '여의도': return '강서'

 elif x['지점'] == '강남구': return '강동'

 elif x['지점'] == '서초구': return '강동'

rawData.apply(func, axis =1 )

#### 		위의 시리즈 값을 그대로 열에 추가!

- rawData['지역'] = rawData.apply(func, axis = 1)

|      | 회차 |   이름 |     측정일 | 몸무게 | 단위 |   담당 |   지점 | 상태 | 지역 |
| ---: | ---: | -----: | ---------: | -----: | ---: | -----: | -----: | ---: | ---: |
|    0 |    1 | 홍길동 | 2020-03-01 |   76.4 |   kg | 박현경 | 관악구 | 비만 | 강서 |
|    1 |    2 | 홍길동 | 2020-03-02 |   75.7 |   kg | 김현경 | 관악구 | 정상 | 강서 |
|    2 |    3 | 홍길동 | 2020-03-03 |   76.0 |   kg | 최현경 | 여의도 | 비만 | 강서 |
|    3 |    4 | 홍길동 | 2020-03-04 |    NaN |   kg | 최현경 | 여의도 |  NaN | 강서 |
|    4 |    5 | 홍길동 | 2020-03-05 |   76.2 |   kg | 김현경 | 강남구 | 비만 | 강동 |
|    5 |    6 | 홍길동 | 2020-03-06 |   75.7 |   kg | 최현경 | 서초구 | 정상 | 강동 |
|    6 |    7 | 홍길동 | 2020-03-07 |    NaN |   kg | 최현경 | 서초구 |  NaN | 강동 |
|    7 |    8 | 홍길동 | 2020-03-08 |    NaN |   kg | 김현경 | 서초구 |  NaN | 강동 |
|    8 |    9 | 홍길동 | 2020-03-09 |   75.0 |   kg | 김현경 | 서초구 | 정상 | 강동 |



## 프레임 합치기

1. 서로 다른 두 자료(데이터 프레임)를 하나로 합치는 방법
2. 여러 소스로부터 가져온 데이터를 분석하기 위해서 반드시 하나로 합쳐야 한다.

### inner join

1. merge 함수를 통해 join 해보자!
   - merge 기본 동작은 'inner join'
2. inner join은 기본적으로 자료의 크기가 훨씬 줄어들게 된다.
   - usage : 240개
   - device : 272 개
     - 두 개를 하나로 합쳤을 때 240개를 넘을 수 없다.

3. pd.merge( left=user_usage, right=user_device, on='use_id')
   - on의 parameter는 inner로 판단할 것으로
   - 즉 같은 use_id에 한해서 inner join 수행

### left join

1. 결측치가 발생할 수 있다.
   - right에 없는 자료!
   - 정확히 left의 자료수 만큼 나온다
2. pd.merge( left=user_usage, right=user_device, on='use_id', how = 'left')
   - how의 parameter로 left 사용

### full outer join

1. pd.merge( left=user_usage, right=user_device, on='use_id', how = 'outer')



## 결론

데이터 전처리 작업의 핵심은!

합치고, 나누고, 붙이고, 자르는 작업이다.



































