## 	배열의 모양

1. 저차원의 배열을 고차원으로 변경
2. 고차원의 배열을 저차원으로 변경
   - 저 차원은 1차원 배열로 변경이 가능
3. 변경 전 / 후의 크기가 일치해야 한다
   - 자료의 개수가 반드시 일치\
4. 저 -> 고차원으로 변경 : display 사용
   - arr1D = np.random.randint(0, 10, size=4 )
   - arr1D.reshpae(2,2) 
   - arr1D.reshpae(-1,2) 
   - arr1D.reshpae(4,1) : 열의 숫자로 행은 알아서 해줌
   - arr1D.reshpae(5,5) : 크기가 다르기 때문에 오류
5. 고 -> 저차원으로 변경 : display 사용
   - arra2D = np.random.randint(1, 10, size = (3,3))
   - arr2D.flatten() / arr2D.ravel() : 행 기준 1행으로
   - arr2D.flatten( order = 'F')



# 넘파이를 이용한 연산



## 	기본적인 연산 수행

## 	자료의 형태

1. 스칼라
2. 벡터 : n행 1열을 일컬음
   - vector = np.random.randint(1, 10, size=5) : 행 벡터
   - vector.reshape(-1, 1) : 열벡터
   - np.zeros(4,1) : 0 열벡터
   - np.ones(4,1) : 1 열벡터
3. 행렬



## 	타입이 다른 피연산자 간의 연산

1. 브로드캐스팅 되는 경우, 안되는 경우로 나뉜다
2. 2*vector
3. 벡터끼리의 연산은 브로드캐스팅이 되지 않기 때문에 반드시 크기가 같아야 한다.
4. 행렬도 벡터와 마찬가지로 브로드캐스팅 되지 않는다
5. 차원이 같으면, 저차원 행렬이 고차원 행렬로 브로드캐스팅 가능하면 연산 가능
6. 같은 차원이면, 반드시 크기가 같아야 한다.











































































